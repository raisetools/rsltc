<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
   "DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<!-- XML file produced from file: ug.tex
     using Hyperlatex v 2.6 (c) Otfried Cheong
     on Emacs 22.1.1, Thu Apr 17 12:52:43 2008 -->
<head>
<title>RAISE Tool User Guide -- 13.2 Translatable RSL constructs</title>

<style type="text/css">
.maketitle { align : center }
div.abstract { margin-left: 20%; margin-right: 10%; }
h3.abstract  { align : center }
div.verse, div.quote, div.quotation {
  margin-left : 10%; 
  margin-right : 10%;
}
</style>


</head>
<body>
<table width="100%" cellpadding="0"><tr>
    <td width="30%"><table width="100%"><tr><td width="12%"><a href="ug_62.html"><img border="0" alt="13.1 Introduction" src="/home/Unuiist/www/icons/previous.gif"></img></a></td><td align="left" valign="middle">13.1 Introduction</td></tr></table></td><td width="30%"><table width="100%"><tr><td width="12%"><a href="ug_61.html"><img border="0" alt="13 SAL Translator" src="/home/Unuiist/www/icons/up.gif"></img></a>
   </td><td align="left" valign="middle">13 SAL Translator</td></tr></table></td><td width="30%"><table width="100%"><tr><td width="12%"><a href="ug_64.html"><img border="0" alt="13.3 Writing transition systems and LTL assertions" src="/home/Unuiist/www/icons/next.gif"></img></a>
   </td><td align="left" valign="middle">13.3 Writing transition systems and LTL assertions</td></tr></table></td></tr><tr><td colspan="4" align="center" bgcolor="#99ccff" width="100%"><font size="+1"><b>13.2 Translatable RSL constructs</b></font></td></tr></table>
<h2>13.2 Translatable RSL constructs</h2>

Regarding V1, in the following subsections RSL constructs are
listed, showing how they are translated to SAL. More implementation details about this, can be found in <a href="ug_78.html#UNUIIST:331">[13]</a>. 
  
<h3><a name="sec:decls">13.2.1 Declarations</a></h3>

Depending on the RSL kind of declaration, a declaration translates to one or more type, constant, function or variable declarations.
      
<h5><a name="id2">Scheme declarations</a></h5>
The RSL <em>Scheme</em> constructor is translated to the SAL CONTEXT constructor.
      
<h4><a name="id3">Object declarations</a></h4>
Object declarations are translated as instantiations of the SAL
CONTEXT. If the applicative specification style is used, then object instantiations only introduce a name space in the current scheme.

<h4><a name="id4">Type declarations</a></h4>

The <em>Boolean</em>, <em>Integer</em>, <em>Natural</em>, <em>Record</em>, <em>Variant</em>
and <em>Collection</em> types are translated. But <em>Sort</em> and <em>Union</em> types are not accepted by the translator.

<h5><a name="id5">Sort</a></h5>
Sort definitions are not accepted.

<h5><a name="id6">Boolean</a></h5>
The RSL <b>Bool</b> type is translated to the BOOLEAN type in SAL.

<h5><a name="id7">Integer</a></h5>
As integer is infinite by definition, it is necessary to impose a
restriction over the possible values of the type. Then the translator
uses a special integer type generated automatically during the
translation as a subtype of the integer basic type of SAL (using
the subrange structure in SAL). The subtyping used is, in RSL,
of the form 
<table cellspacing="1" cellpadding="0"><tr>
<td nowrap colspan="1" align="left">
                            &nbsp;&nbsp;&nbsp;</td><td nowrap colspan="1" align="left">&nbsp;&nbsp;&nbsp;</td><td nowrap colspan="1" align="left">&nbsp;&nbsp;&nbsp;</td><td nowrap colspan="1" align="left">&nbsp;&nbsp;&nbsp;</td><td nowrap colspan="1" align="left">&nbsp;&nbsp;&nbsp;</td><td nowrap colspan="1" align="left">&nbsp;&nbsp;&nbsp;</td><td nowrap colspan="1" align="left">&nbsp;&nbsp;&nbsp;</td><td nowrap colspan="1" align="left">&nbsp;&nbsp;&nbsp;</td><td nowrap colspan="1" align="left">&nbsp;&nbsp;&nbsp;</td><td nowrap colspan="1" align="left">&nbsp;&nbsp;&nbsp;</td><td nowrap colspan="1" align="left">&nbsp;&nbsp;&nbsp;</td><td nowrap colspan="1" align="left">&nbsp;&nbsp;&nbsp;</td><td nowrap colspan="99" align="left">&nbsp;</td></tr>
<tr>
<td nowrap colspan="99" align="left">&nbsp;<b>type</b></td></tr>
<tr>
<td nowrap colspan="1" align="left"></td><td nowrap colspan="99" align="left">&nbsp;Int&#95; = &#123;| x : <b>Int</b> &#8226; x &#8712; &#123;DefaultIntLow .. DefaultIntHigh&#125; |&#125;
</td></tr></table>

                        <p><p>The tool generates a file (IT&#95;AN.sal) where the
Integer type definition is:
<p><tt>Int&#95;: TYPE = [SAL&#95;GLOBAL!DefaultIntLow..SAL&#95;GLOBAL!DefaultIntHigh];
</tt>
<p>SAL&#95;GLOBAL.sal is the name of the SAL file (also generated by the
tool) where <tt>DefaultIntLow</tt> and <tt>DefaultIntHigh</tt> are defined.
By default, they are defined as -4 and 4 respectively, but this can be
changed by the RSL specification, If a value definition of the form
<table cellspacing="1" cellpadding="0"><tr>
<td nowrap colspan="1" align="left">
                            &nbsp;&nbsp;&nbsp;</td><td nowrap colspan="1" align="left">&nbsp;&nbsp;&nbsp;</td><td nowrap colspan="1" align="left">&nbsp;&nbsp;&nbsp;</td><td nowrap colspan="1" align="left">&nbsp;&nbsp;&nbsp;</td><td nowrap colspan="1" align="left">&nbsp;&nbsp;&nbsp;</td><td nowrap colspan="1" align="left">&nbsp;&nbsp;&nbsp;</td><td nowrap colspan="1" align="left">&nbsp;&nbsp;&nbsp;</td><td nowrap colspan="1" align="left">&nbsp;&nbsp;&nbsp;</td><td nowrap colspan="1" align="left">&nbsp;&nbsp;&nbsp;</td><td nowrap colspan="1" align="left">&nbsp;&nbsp;&nbsp;</td><td nowrap colspan="1" align="left">&nbsp;&nbsp;&nbsp;</td><td nowrap colspan="1" align="left">&nbsp;&nbsp;&nbsp;</td><td nowrap colspan="99" align="left">&nbsp;</td></tr>
<tr>
<td nowrap colspan="99" align="left">&nbsp;<b>value</b></td></tr>
<tr>
<td nowrap colspan="1" align="left"></td><td nowrap colspan="99" align="left">&nbsp;IntHigh : T = n
</td></tr></table>

                        <p>is included in the specification being translated, where the type T is
<b>Int</b> or any subtype of <b>Int</b>, and n is a literal, then n will
be used as the value of <tt>DefaultIntHigh</tt> in SAL&#95;GLOBAL.sal.  A similar
definition of IntLow will cause its value to be used as the value of
<tt>DefaultIntLow</tt>.
<p>It is necessary to make sure that DefaultIntHigh and DefaultIntLow are
set to include any integer values generated when model
checking the specification, since
<ul><p><li>Integer arithmetic on range types in SAL is actually modulo
  arithmetic, to keep within within the bounds.  Hence it only models
  RSL arithmetic properly when the bounds are wide enough.
<p><li>Exceeding the bounds for integers will cause errors to be
  generated in the CC version.
</ul>
   

<h5><a name="id8">Natural</a></h5>
Natural type is translated similarly to Integer type. The SAL subrange
structure is used. The subtyping is, in RSL,
of the form, 
<table cellspacing="1" cellpadding="0"><tr>
<td nowrap colspan="1" align="left">
                            &nbsp;&nbsp;&nbsp;</td><td nowrap colspan="1" align="left">&nbsp;&nbsp;&nbsp;</td><td nowrap colspan="1" align="left">&nbsp;&nbsp;&nbsp;</td><td nowrap colspan="1" align="left">&nbsp;&nbsp;&nbsp;</td><td nowrap colspan="1" align="left">&nbsp;&nbsp;&nbsp;</td><td nowrap colspan="1" align="left">&nbsp;&nbsp;&nbsp;</td><td nowrap colspan="1" align="left">&nbsp;&nbsp;&nbsp;</td><td nowrap colspan="1" align="left">&nbsp;&nbsp;&nbsp;</td><td nowrap colspan="1" align="left">&nbsp;&nbsp;&nbsp;</td><td nowrap colspan="1" align="left">&nbsp;&nbsp;&nbsp;</td><td nowrap colspan="1" align="left">&nbsp;&nbsp;&nbsp;</td><td nowrap colspan="1" align="left">&nbsp;&nbsp;&nbsp;</td><td nowrap colspan="99" align="left">&nbsp;</td></tr>
<tr>
<td nowrap colspan="99" align="left">&nbsp;<b>type</b></td></tr>
<tr>
<td nowrap colspan="1" align="left"></td><td nowrap colspan="99" align="left">&nbsp;Nat&#95; = &#123;| x : <b>Nat</b> &#8226; x &#8712; &#123;0 .. DefaultNatHigh&#125; &#125;|
</td></tr></table>

                        <p>The tool generates a file (NT&#95;AN.sal) where the
Natural type definition is:
<p><tt>Nat&#95;: TYPE = [0..SAL&#95;GLOBAL!DefaultNatHigh];
</tt>
<p>DefaultNatHigh is by default set to 4, but this value can be changed
in a similar fashion to DefaultIntHigh, by including in the
specification a value definition of the form
<table cellspacing="1" cellpadding="0"><tr>
<td nowrap colspan="1" align="left">
                            &nbsp;&nbsp;&nbsp;</td><td nowrap colspan="1" align="left">&nbsp;&nbsp;&nbsp;</td><td nowrap colspan="1" align="left">&nbsp;&nbsp;&nbsp;</td><td nowrap colspan="1" align="left">&nbsp;&nbsp;&nbsp;</td><td nowrap colspan="1" align="left">&nbsp;&nbsp;&nbsp;</td><td nowrap colspan="1" align="left">&nbsp;&nbsp;&nbsp;</td><td nowrap colspan="1" align="left">&nbsp;&nbsp;&nbsp;</td><td nowrap colspan="1" align="left">&nbsp;&nbsp;&nbsp;</td><td nowrap colspan="1" align="left">&nbsp;&nbsp;&nbsp;</td><td nowrap colspan="1" align="left">&nbsp;&nbsp;&nbsp;</td><td nowrap colspan="1" align="left">&nbsp;&nbsp;&nbsp;</td><td nowrap colspan="1" align="left">&nbsp;&nbsp;&nbsp;</td><td nowrap colspan="99" align="left">&nbsp;</td></tr>
<tr>
<td nowrap colspan="99" align="left">&nbsp;<b>value</b></td></tr>
<tr>
<td nowrap colspan="1" align="left"></td><td nowrap colspan="99" align="left">&nbsp;NatHigh : T = n
</td></tr></table>

                        <p>where the type T is
<b>Int</b> or any subtype of <b>Int</b>, and n is a literal.
<p>Just as for integers, DefaultNatHigh needs to be large enough to
include any natural values generated during model checking.

<h5><a name="id9">Variant  type</a></h5>
Variants are translated to the type declarator DATATYPE in SAL. For
example, consider this example (<a href="ug_78.html#RLG92">[1]</a>, pg. 96)
<table cellspacing="1" cellpadding="0"><tr>
<td nowrap colspan="1" align="left">
                            &nbsp;&nbsp;&nbsp;</td><td nowrap colspan="1" align="left">&nbsp;&nbsp;&nbsp;</td><td nowrap colspan="1" align="left">&nbsp;&nbsp;&nbsp;</td><td nowrap colspan="1" align="left">&nbsp;&nbsp;&nbsp;</td><td nowrap colspan="1" align="left">&nbsp;&nbsp;&nbsp;</td><td nowrap colspan="1" align="left">&nbsp;&nbsp;&nbsp;</td><td nowrap colspan="1" align="left">&nbsp;&nbsp;&nbsp;</td><td nowrap colspan="1" align="left">&nbsp;&nbsp;&nbsp;</td><td nowrap colspan="1" align="left">&nbsp;&nbsp;&nbsp;</td><td nowrap colspan="1" align="left">&nbsp;&nbsp;&nbsp;</td><td nowrap colspan="1" align="left">&nbsp;&nbsp;&nbsp;</td><td nowrap colspan="1" align="left">&nbsp;&nbsp;&nbsp;</td><td nowrap colspan="99" align="left">&nbsp;</td></tr>
<tr>
<td nowrap colspan="99" align="left">&nbsp;<b>type</b></td></tr>
<tr>
<td nowrap colspan="1" align="left"></td><td nowrap colspan="99" align="left">&nbsp;List == empty | add(head : Elem &#8596; replace&#95;head, tail : List)
</td></tr></table>

                        <p><p>is translated to
<pre>
List: TYPE = DATATYPE
  empty,
  add(head: Elem, tail: List) 
END;

replace_head(z_: Elem, x_: List) : List =
  LET x1_ : Elem = head(x_) IN
  LET x2_ : List = tail(x_) IN
    add(z_ , x2_)
</pre>
<p><b>Note</b> that reconstructor declarations (in this case "replace&#95;head") are translated as explicit functions.

<h5><a name="id10">Record type</a></h5>
RSL defines records as short variant definitions. Variants in SAL are
defined with the type declarator "DATATYPE". Therefore record
definition is translated to DATATYPE in SAL.

<h5><a name="id11">Union type</a></h5>
Union type is not translatable into SAL.

<h5><a name="id12">Collection  type (set, map, list) </a></h5>
The strategy for translating sets and maps relies on an encoding based
on total functions. The definition of the operations over sets and
maps use LAMBDA functions. 
<ul><p><li><b>Set type</b>
The translation for sets uses an implementation based on a function
from the domain of the set into a boolean value. For example, this type declaration:
<table cellspacing="1" cellpadding="0"><tr>
<td nowrap colspan="1" align="left">
                            &nbsp;&nbsp;&nbsp;</td><td nowrap colspan="1" align="left">&nbsp;&nbsp;&nbsp;</td><td nowrap colspan="1" align="left">&nbsp;&nbsp;&nbsp;</td><td nowrap colspan="1" align="left">&nbsp;&nbsp;&nbsp;</td><td nowrap colspan="1" align="left">&nbsp;&nbsp;&nbsp;</td><td nowrap colspan="1" align="left">&nbsp;&nbsp;&nbsp;</td><td nowrap colspan="1" align="left">&nbsp;&nbsp;&nbsp;</td><td nowrap colspan="1" align="left">&nbsp;&nbsp;&nbsp;</td><td nowrap colspan="1" align="left">&nbsp;&nbsp;&nbsp;</td><td nowrap colspan="1" align="left">&nbsp;&nbsp;&nbsp;</td><td nowrap colspan="1" align="left">&nbsp;&nbsp;&nbsp;</td><td nowrap colspan="1" align="left">&nbsp;&nbsp;&nbsp;</td><td nowrap colspan="99" align="left">&nbsp;</td></tr>
<tr>
<td nowrap colspan="99" align="left">&nbsp;<b>type</b></td></tr>
<tr>
<td nowrap colspan="1" align="left"></td><td nowrap colspan="99" align="left">&nbsp;Set1 = <b>Nat</b><b>-set</b>
</td></tr></table>

                        <p>will be translated into SAL as:
<p><tt>Nat&#95;set: TYPE = [NT&#95;AN!Nat&#95; <i>-</i><i>&gt;</i> BT&#95;AN!Bool&#95;];
<p>Set1: TYPE = Nat&#95;set;
</tt>
<p><li><b>Map type</b>
Maps are also defined as functions but are in general not defined over
all possible values in their domains. In this case, a map application
over a value not in the map's domain will return the value <em>swap</em>.
<p>SAL does not provide partial function support, so partial
constructions are not directly translatable. The translator modifies
the map by creating a variant declaration. This declaration turns the
map into a total function. For example, the following map definition
<table cellspacing="1" cellpadding="0"><tr>
<td nowrap colspan="1" align="left">
                            &nbsp;&nbsp;&nbsp;</td><td nowrap colspan="1" align="left">&nbsp;&nbsp;&nbsp;</td><td nowrap colspan="1" align="left">&nbsp;&nbsp;&nbsp;</td><td nowrap colspan="1" align="left">&nbsp;&nbsp;&nbsp;</td><td nowrap colspan="1" align="left">&nbsp;&nbsp;&nbsp;</td><td nowrap colspan="1" align="left">&nbsp;&nbsp;&nbsp;</td><td nowrap colspan="1" align="left">&nbsp;&nbsp;&nbsp;</td><td nowrap colspan="1" align="left">&nbsp;&nbsp;&nbsp;</td><td nowrap colspan="1" align="left">&nbsp;&nbsp;&nbsp;</td><td nowrap colspan="1" align="left">&nbsp;&nbsp;&nbsp;</td><td nowrap colspan="1" align="left">&nbsp;&nbsp;&nbsp;</td><td nowrap colspan="1" align="left">&nbsp;&nbsp;&nbsp;</td><td nowrap colspan="99" align="left">&nbsp;</td></tr>
<tr>
<td nowrap colspan="99" align="left">&nbsp;<b>type</b></td></tr>
<tr>
<td nowrap colspan="1" align="left"></td><td nowrap colspan="99" align="left">&nbsp;MyMap = T1 -m-&gt; T2
</td></tr></table>

                        <p><p>is translated to
<pre>
T1_T2_map_range: TYPE = DATATYPE  
  T1_T2_map_nil,
  T1_T2_map_range(T1_T2_map_val: T2)
END;

T1_T2_map: TYPE = [T1 -&gt; T1_T2_map_Range];

MyMap: TYPE = T1_T2_map;

T1_set: TYPE = [T1 -&gt; Bool_];
</pre>
<p>Non deterministic maps are not accepted in the translator. For example,
the expression
<font size="-1">[ x &#8614; y | x, y : <b>Nat</b> &#8226; &#123;x,y&#125; &#8838; &#123;1, 2&#125;
  ]</font> cannot be translated to SAL. Infinite maps (as in <font size="-1">[ n &#8614; 2 * n | n : <b>Nat</b> &#8226;
  is&#95;a&#95;prime(n) ] </font>
  ) are not accepted for the translator.
<p><li><b>List type</b> List definitions are not accepted.
</ul>

<h4><a name="id13">Value declarations</a></h4>


<h5><a name="id14">Typings</a></h5>
Value definitions of the form "identifier: type
expression" (called <em>typings</em>) are not accepted by the translator.

<h5><a name="id15">Explicit value definitions</a></h5>
Explicit value definitions are translated to a constant declarations in the model. 

<h5><a name="id16">Implicit value definitions</a></h5>
Implicit value definitions are not accepted by the translator.

<h5><a name="id17">Function definitions</a></h5>

<ul><p><li><b>Explicit function definitions</b> 
Explicit function definitions are translated to SAL explicit
functions. The name of the function must be unique in the scheme. An
example of a RSL declaration is
<table cellspacing="1" cellpadding="0"><tr>
<td nowrap colspan="1" align="left">
                            &nbsp;&nbsp;&nbsp;</td><td nowrap colspan="1" align="left">&nbsp;&nbsp;&nbsp;</td><td nowrap colspan="1" align="left">&nbsp;&nbsp;&nbsp;</td><td nowrap colspan="1" align="left">&nbsp;&nbsp;&nbsp;</td><td nowrap colspan="1" align="left">&nbsp;&nbsp;&nbsp;</td><td nowrap colspan="1" align="left">&nbsp;&nbsp;&nbsp;</td><td nowrap colspan="1" align="left">&nbsp;&nbsp;&nbsp;</td><td nowrap colspan="1" align="left">&nbsp;&nbsp;&nbsp;</td><td nowrap colspan="1" align="left">&nbsp;&nbsp;&nbsp;</td><td nowrap colspan="1" align="left">&nbsp;&nbsp;&nbsp;</td><td nowrap colspan="1" align="left">&nbsp;&nbsp;&nbsp;</td><td nowrap colspan="1" align="left">&nbsp;&nbsp;&nbsp;</td><td nowrap colspan="99" align="left">&nbsp;</td></tr>
<tr>
<td nowrap colspan="99" align="left">&nbsp;<b>value</b></td></tr>
<tr>
<td nowrap colspan="1" align="left"></td><td nowrap colspan="99" align="left">&nbsp;sum : <b>Int</b> &#215; <b>Int</b> &#8594; <b>Int</b></td></tr>
<tr>
<td nowrap colspan="1" align="left"></td><td nowrap colspan="99" align="left">&nbsp;sum(x,y) &#8801; x + y 
</td></tr></table>

                        <p><p>is translated to the SAL function 
<p><tt>sum(x:IT&#95;AN!Int&#95; , y:IT&#95;AN!Int&#95;) : IT&#95;AN!Int&#95; = x + y;
</tt>
<p>If the function name is overloaded in the specification, an error is
reported during the translation. The same happens when operators are
overloaded.
<p>SAL does not have predefined operators over sets and maps. The
translator generates a file with macro declarations containing the names for
the set and map operations. It will be expanded before model checking
the specification. Table <a href="#Table1">13.2.1</a> and table <a href="#Table2">13.2.1</a> show function names for set operators
and map operators.
<div align="center"><p>
<table><tbody><tr><td colspan="1" align="CENTER">

Operator </td><td colspan="1" align="CENTER"> Function name </td></tr>
<tr><td colspan="1" align="CENTER">
x = y  </td><td colspan="1" align="CENTER"> = </td></tr>
<tr><td colspan="1" align="CENTER">
x &#8800; y </td><td colspan="1" align="CENTER"> /= </td></tr>
<tr><td colspan="1" align="CENTER">
x &#8835; y </td><td colspan="1" align="CENTER"> strict&#95;supset?(x, y) </td></tr>
<tr><td colspan="1" align="CENTER">
x &#8834; y </td><td colspan="1" align="CENTER"> strict&#95;subset?(x, y) </td></tr>
<tr><td colspan="1" align="CENTER">
x &#8838; y </td><td colspan="1" align="CENTER"> supset?(x, y) </td></tr>
<tr><td colspan="1" align="CENTER">
x &#8838; y </td><td colspan="1" align="CENTER"> subset?(x, y)  </td></tr>
<tr><td colspan="1" align="CENTER">
x &#8713; y </td><td colspan="1" align="CENTER"> not&#95;isin(x, y) </td></tr>
<tr><td colspan="1" align="CENTER">
x &#8745; y </td><td colspan="1" align="CENTER"> intersection(x, y) </td></tr>
<tr><td colspan="1" align="CENTER">
x &#92; y </td><td colspan="1" align="CENTER"> difference(x,y) </td></tr>
<tr><td colspan="1" align="CENTER">
x &#8746; y </td><td colspan="1" align="CENTER"> union(x, y) </td></tr>
<tr><td colspan="1" align="CENTER">
x &#8712; y </td><td colspan="1" align="CENTER"> isin(x, y) </td></tr>
<tr><td colspan="1" align="CENTER">
</td></tr></tbody></table>

<div align="center"><a name="Table1"> Function</a> names for set operators</div>
</p></div>
<div align="center"><p>
<table><tbody><tr><td colspan="1" align="CENTER">

Operator </td><td colspan="1" align="CENTER"> Function name </td></tr>
<tr><td colspan="1" align="CENTER">
x = y  </td><td colspan="1" align="CENTER"> = </td></tr>
<tr><td colspan="1" align="CENTER">
x &#8800; y </td><td colspan="1" align="CENTER"> /= </td></tr>
<tr><td colspan="1" align="CENTER">
x &#8224; y </td><td colspan="1" align="CENTER"> override(x, y) </td></tr>
<tr><td colspan="1" align="CENTER">
<b>rng</b> x  </td><td colspan="1" align="CENTER"> rng(x) </td></tr>
<tr><td colspan="1" align="CENTER">
x / y </td><td colspan="1" align="CENTER"> restriction&#95;to(x, y) </td></tr>
<tr><td colspan="1" align="CENTER">
x &#92; y </td><td colspan="1" align="CENTER"> restriction&#95;by(x, y) </td></tr>
<tr><td colspan="1" align="CENTER">
<b>dom</b> x </td><td colspan="1" align="CENTER"> dom(x) </td></tr>
<tr><td colspan="1" align="CENTER">
</td></tr></tbody></table>

<div align="center"><a name="Table2"> Function</a> names for map operators</div>
</p></div>
<p><li><b>Partial function definitions</b>
<p>SAL does not support partial functions. The translator assumes that
all preconditions of partial functions are verified. The tool, in V1, translates partial functions
as SAL total functions. For example,
<table cellspacing="1" cellpadding="0"><tr>
<td nowrap colspan="1" align="left">
                            &nbsp;&nbsp;&nbsp;</td><td nowrap colspan="1" align="left">&nbsp;&nbsp;&nbsp;</td><td nowrap colspan="1" align="left">&nbsp;&nbsp;&nbsp;</td><td nowrap colspan="1" align="left">&nbsp;&nbsp;&nbsp;</td><td nowrap colspan="1" align="left">&nbsp;&nbsp;&nbsp;</td><td nowrap colspan="1" align="left">&nbsp;&nbsp;&nbsp;</td><td nowrap colspan="1" align="left">&nbsp;&nbsp;&nbsp;</td><td nowrap colspan="1" align="left">&nbsp;&nbsp;&nbsp;</td><td nowrap colspan="1" align="left">&nbsp;&nbsp;&nbsp;</td><td nowrap colspan="1" align="left">&nbsp;&nbsp;&nbsp;</td><td nowrap colspan="1" align="left">&nbsp;&nbsp;&nbsp;</td><td nowrap colspan="1" align="left">&nbsp;&nbsp;&nbsp;</td><td nowrap colspan="99" align="left">&nbsp;</td></tr>
<tr>
<td nowrap colspan="99" align="left">&nbsp;<b>value</b></td></tr>
<tr>
<td nowrap colspan="1" align="left"></td><td nowrap colspan="99" align="left">&nbsp;diff : <b>Nat</b> &#215; <b>Nat</b> -~-&gt; <b>Nat</b></td></tr>
<tr>
<td nowrap colspan="1" align="left"></td><td nowrap colspan="99" align="left">&nbsp;diff(x,y) &#8801; x - y</td></tr>
<tr>
<td nowrap colspan="1" align="left"></td><td nowrap colspan="99" align="left">&nbsp;<b>pre</b> x &#8805; y
</td></tr></table>

                        <p><p>is translated to
<p><tt>diff(x:NT&#95;!Nat&#95; , y:NT&#95;!Nat&#95;): NT&#95;!Nat&#95; = x - y;
</tt>
<p><li><b>Recursive function definitions</b> As in SAL, recursive function definitions are not accepted by the translator.
<p><li><b>Implicit function definitions</b> Implicit function definitions
  are not accepted by the translator.
</ul>

<h4><a name="id20">Variable declarations</a></h4>
Variable declarations are not
accepted by the translator. 

<h4><a name="id21">Channel declarations</a></h4>
Channel declarations are not
accepted by the translator.

<h4><a name="id22">Axiom declarations</a></h4>
Axiom declarations are not
accepted by the translator. 

<h4><a name="id23">Test case declarations</a></h4>
Test case declarations are
ignored by the translator.

<h3><a name="id24">13.2.2 Class expressions</a></h3>
The translation of a class expression results in the translation of
its declarations and its statements.
     
<h4><a name="id25">Extending class expressions</a></h4>
Extending class
     expressions are translated as a new class declarations. An
     extending class expression includes all the extended class declarations.
     
<h4><a name="id26">Hiding class expressions</a></h4>
Hiding class expressions
     are ignored by the translator.
     
<h4><a name="id27">Renaming class expressions</a></h4>
Renaming class expressions
     are ignored by the translator.
     
<h4><a name="id28">With expressions</a></h4>
With expressions 
     are ignored by the translator.
     
<h4><a name="id29">Scheme instantiations</a></h4>
The translator only works with
     specifications written in an applicative style. So, the role of
     schemes is to provide type and value
     declarations. 
  
<h3><a name="id30">13.2.3 Object expressions</a></h3>
An object expression which is an "object name" is accepted as a
qualification. The following example, shows how
object expressions are translated. 
<table cellspacing="1" cellpadding="0"><tr>
<td nowrap colspan="1" align="left">
                            &nbsp;&nbsp;&nbsp;</td><td nowrap colspan="1" align="left">&nbsp;&nbsp;&nbsp;</td><td nowrap colspan="1" align="left">&nbsp;&nbsp;&nbsp;</td><td nowrap colspan="1" align="left">&nbsp;&nbsp;&nbsp;</td><td nowrap colspan="1" align="left">&nbsp;&nbsp;&nbsp;</td><td nowrap colspan="1" align="left">&nbsp;&nbsp;&nbsp;</td><td nowrap colspan="1" align="left">&nbsp;&nbsp;&nbsp;</td><td nowrap colspan="1" align="left">&nbsp;&nbsp;&nbsp;</td><td nowrap colspan="1" align="left">&nbsp;&nbsp;&nbsp;</td><td nowrap colspan="1" align="left">&nbsp;&nbsp;&nbsp;</td><td nowrap colspan="1" align="left">&nbsp;&nbsp;&nbsp;</td><td nowrap colspan="1" align="left">&nbsp;&nbsp;&nbsp;</td><td nowrap colspan="99" align="left">&nbsp;</td></tr>
<tr>
<td nowrap colspan="99" align="left">&nbsp;<b>object</b> N : NAMES</td></tr>
<tr>
<td nowrap colspan="99" align="left">&nbsp;<b>value</b></td></tr>
<tr>
<td nowrap colspan="1" align="left"></td><td nowrap colspan="99" align="left">&nbsp;f : N.Name &#8594; <b>Bool</b></td></tr>
<tr>
<td nowrap colspan="1" align="left"></td><td nowrap colspan="99" align="left">&nbsp;f(n) &#8801; N.to&#95;bool(n)
</td></tr></table>

                        <p><p>is translated to
<pre>
  f(n: SAL\_TYPES!Name) : Bool_ = NAMES!to_bool(n);
</pre>
<p>Neither object array expressions nor fitting object expression are accepted by the translator.
 
<h3><a name="id31">13.2.4 Type expressions</a></h3>
RSL's basic type system uses the SAL type system for translating RSL
type expressions.
      
<h4><a name="id32">Type names</a></h4>
Type names translate to type names.
      
<h4><a name="id33">Product type expressions</a></h4>
Product type expressions translate to SAL tuple declarations. For
example,
<p><font size="-1">MyProd = <b>Nat</b> &#215; <b>Bool</b> &#215; <b>Int</b> </font>
<p>is translated to
<p><tt>Prod : TYPE = [NT&#95;AN!Nat&#95; , BT&#95;AN!Bool&#95; , IT&#95;AN!Int&#95;]; </tt>
      
<h4><a name="id34">Set type expressions</a></h4>
The translator generates a new set context for every
set declaration/type expression found. Multiple set declarations of the same domain type
are avoided. Set type expressions like,
<p><font size="-1">MySet = (<b>Nat</b> &#215; <b>Int</b>)-set</font>
<p>are rejected by the translator.
<p>Only sets in which the 
domain is either a basic type or a defined type are accepted. So the expression in
the previous example must be
changed into:
<p><font size="-1">MyData = <b>Nat</b> &#215; <b>Int</b>,
<p>MySet = MyData-<b>set</b>
</font>
      
<h4><a name="id35">List type expressions</a></h4>
List type expressions are not accepted by the translator.
      
<h4><a name="id36">Map type expressions</a></h4>
As in set type expressions, the translator generates a new finite map
context for every map declaration/type expression found. Multiple map
declarations of the same domain type are avoided. 
<p>Neither infinite maps nor non-deterministic map type expressions are
allowed by the translator.
      
<h4><a name="id37">Function type expressions</a></h4>
In general, the way to translate function type expressions is shown in
<a href="#id17">13.2.1</a>. However, there are some exceptions:
<ul><p><li>Curried functions are transformed into lambda functions.
   <p><li>Function-type declared values are declared as function
     type and the value expression (a lambda abstraction expression)
     is assigned to it. For example, 
<p><font size="-1"><table cellspacing="1" cellpadding="0"><tr>
<td nowrap colspan="1" align="left">
                            &nbsp;&nbsp;&nbsp;</td><td nowrap colspan="1" align="left">&nbsp;&nbsp;&nbsp;</td><td nowrap colspan="1" align="left">&nbsp;&nbsp;&nbsp;</td><td nowrap colspan="1" align="left">&nbsp;&nbsp;&nbsp;</td><td nowrap colspan="1" align="left">&nbsp;&nbsp;&nbsp;</td><td nowrap colspan="1" align="left">&nbsp;&nbsp;&nbsp;</td><td nowrap colspan="1" align="left">&nbsp;&nbsp;&nbsp;</td><td nowrap colspan="1" align="left">&nbsp;&nbsp;&nbsp;</td><td nowrap colspan="1" align="left">&nbsp;&nbsp;&nbsp;</td><td nowrap colspan="1" align="left">&nbsp;&nbsp;&nbsp;</td><td nowrap colspan="1" align="left">&nbsp;&nbsp;&nbsp;</td><td nowrap colspan="1" align="left">&nbsp;&nbsp;&nbsp;</td><td nowrap colspan="99" align="left">&nbsp;</td></tr>
<tr>
<td nowrap colspan="99" align="left">&nbsp;<b>value</b></td></tr>
<tr>
<td nowrap colspan="1" align="left"></td><td nowrap colspan="99" align="left">&nbsp;sum: <b>Int</b> &#215; <b>Int</b> &#8594; <b>Int</b> = &#955; (x,y) : <b>Int</b> &#215; <b>Int</b> &#8226; x+y
</td></tr></table>

                        <p></font>
<p>is translated to
<p><tt>sum :[ [IT&#95;AN!Int&#95;, IT&#95;AN!Int&#95;] -&gt; IT&#95;AN!Int&#95; ] = 
<p>LAMBDA (x:IT&#95;AN!Int&#95;, y:IT&#95;AN!Int&#95;): x + y;
</tt>
</ul> 
      
<h4><a name="id38">Subtype expressions</a></h4>
Subtype expressions are translated to SAL subtype declarations. For
example, the following subtype expression, 
<p><font size="-1"><p>T = &#123; | (x,y): <b>Int</b> &#215; <b>Int</b> &#8226; x <i>&gt;</i> y
| &#125;
</font>
<p>is translated to
<p><tt><p> T: TYPE = &#123;TypeId1&#95; :[IT&#95;AN!Int&#95;, IT&#95;AN!Int&#95;] | TypeId1&#95;.1 &gt;
 TypeId1&#95;.2&#125;;
</tt>
<p>There are four special case for <b>Int</b> and <b>Nat</b>:
<ul><p><li><font size="-1"><p>T1 = &#123; | x: <b>Int</b> &#8226; x &#8712;
&#123;a..b&#125; | &#125;
</font>
<p>is translated to
<p><tt>T1: TYPE = [a..b]
<p></tt>
<p><li><font size="-1"><p>T2 = &#123; | x: <b>Nat</b> &#8226; x &#8712;
&#123;a..b&#125; | &#125;
</font>
<p>is translated to
<p><tt>T2: TYPE = [a..b]
<p></tt>
<p><li><font size="-1">T3 = &#123; | x: <b>Nat</b> &#8226; x <i>&lt;</i><i>=</i> a
| &#125;
</font>
<p>is translated to
<p><tt>T3: TYPE = [0..a];
</tt>
<p><li><font size="-1">T4 = &#123; | x: <b>Nat</b> &#8226; x <i>&lt;</i> a
| &#125;
</font>
<p>is translated to
<p><tt>T4: TYPE = [0..a-1];
</tt>
</ul>
      
<h4><a name="id39">Bracketed type expressions</a></h4>
A bracketed type expression translates as its constituent type expression.
 
<h3><a name="id40">13.2.5 Value expressions</a></h3>
Value expressions are translated of different forms.
      
<h4><a name="id41">Value literals</a></h4>
The RSL value literals <b>Bool</b>, <b>Int</b> and <b>Nat</b> are
translated but <b>Unit</b>, <b>Real</b>, <b>Char</b> and <b>Text</b> are not accepted by the translator.
       
<h4><a name="id42">Names</a></h4>
A name translates as a name.
       
<h4><a name="id43">Pre names</a></h4>
Pre names are not accepted by the translator.
       
<h4><a name="id44">Basic expression</a></h4>
The RSL basic expression <em>skip</em> is ignored and <em>stop</em>, <em>chaos</em> and <em>swap</em> are not accepted in the translator.
       
<h4><a name="id45">Product expressions</a></h4>
A product expression
       translates to a SAL tuple.
       
<h4><a name="SetExpressions">Set expressions</a></h4>
 All set expressions are accepted
       by the translator. Set expressions are modelled as total
       functions. They return true when they are applied to a member
       of the set, and false otherwise. The table <a href="#Table3">13.2.5</a>, shows
       as set expressions are
       translated to SAL. The
       context name “SET&#95;OPS” is used only for illustrative purposes.
<div align="center"><p>
<table><tbody><tr><td colspan="1" align="CENTER">

RSL </td><td colspan="1" align="CENTER"> SAL </td></tr>
<tr><td colspan="1" align="CENTER">
<font size="-1">&#123;&#125;</font>  </td><td colspan="1" align="CENTER"> <tt>SET&#95;OPS!emptySet</tt> </td></tr>
<tr><td colspan="1" align="CENTER">
<font size="-1">&#123;x, y&#125;</font> </td><td colspan="1" align="CENTER"> <tt>SET&#95;OPS!add(x, SET&#95;OPS!add(y, SET&#95;OPS!emptySet))</tt> </td></tr>
<tr><td colspan="1" align="CENTER">
<font size="-1">&#123;x .. y&#125;</font> </td><td colspan="1" align="CENTER"> <tt>LAMBDA (z :IT&#95;AN!Int&#95;): x &lt;= z AND z &lt;= y</tt> </td></tr>
<tr><td colspan="1" align="CENTER">
<font size="-1">&#123; b | b : T <b>•</b> p(b) &#125;</font> </td><td colspan="1" align="CENTER"> <tt>LAMBDA (b :T): p(b)</tt> </td></tr>
<tr><td colspan="1" align="CENTER">
<font size="-1">&#123; f(b) | b : T <b>•</b> p(b) &#125;</font> </td><td colspan="1" align="CENTER"> <tt>LAMBDA (u :U):  EXISTS (b :T) :  p(b) AND f(b) = u</tt> </td></tr>
<tr><td colspan="1" align="CENTER">
</td></tr></tbody></table>

<div align="center"><a name="Table3"> Set</a> expressions</div>
</p></div>
       
<h4><a name="id48">List expressions</a></h4>
List expressions are not
       accepted by the translator.
       
<h4><a name="id49">Map expressions</a></h4>
Generally map expressions are
       accepted, but they are not checked in order to verify if the
       resulting maps are deterministic. The table <a href="#Table4">13.2.5</a>,
       shows as set expressions are
       translated to SAL. The
       context name “MAP&#95;OPS” is used only for illustrative purposes.
<div align="center"><p>
<table><tbody><tr><td colspan="1" align="CENTER">

RSL </td><td colspan="1" align="CENTER"> SAL</td></tr>
<tr><td colspan="1" align="CENTER">
<font size="-1">[ ]</font>  </td><td colspan="1" align="CENTER"> <tt>MAP&#95;OPS!emptyMap</tt> </td></tr>
<tr><td colspan="1" align="CENTER">
<font size="-1">[ x &#8614; p, y &#8614; q ]</font> </td><td colspan="1" align="CENTER"> <tt>MAP&#95;OPS!add(x,p,MAP&#95;OPS!add(y,q,MAP&#95;OPS!emptyMap))</tt> </td></tr>
<tr><td colspan="1" align="CENTER">
<font size="-1">[ b &#8614; e | b : T <b>.</b> p ]</font> </td><td colspan="1" align="CENTER"> <tt>LAMBDA (b :T): IF p THEN m(e)=b ELSE nil ENDIF</tt> </td></tr>
<tr><td colspan="1" align="CENTER">
</td></tr></tbody></table>

<div align="center"><a name="Table4"> Map</a> expressions</div>
</p></div>
Map expressions matching the pattern 
<p>[ e1(x) &#8614; e2(x) | x : T <b>.</b> p(x) ]
<p>(where e1 : T &#8594; U1, e2 : T &#8594; U2),
are not accepted by the translator (because there is no way, in general, to generate the inverse function of “e1”).
       
<h4><a name="id51">List application expressions</a></h4>
List application
       expressions are not accepted by the translator.
       
<h4><a name="id52">Function expressions</a></h4>
Function expressions are
       translated to SAL's LAMBDA abstraction.
       
<h4><a name="id53">Application expressions</a></h4>
An application
       expression is translated to a function call or a map
       application. List applications are not accepted by the translator.
       
<h4><a name="id54">Quantified expressions</a></h4>
All quantified
       expressions are accepted. Regarding the translation mechanism,
       except <i>exist </i>!, all
       quantifiers are directly supported by SAL. The translation of
       the &#8707;! expression is described following,
<p><tt>EXISTS (x:T) : p(x) AND ( FORALL (x1:T) : p(x1) =&gt; x = x1 ) </tt> 
       
<h4><a name="id55">Equivalence expressions</a></h4>
Equivalence expressions
       are translated to SAL equalities.
       
<h4><a name="id56">Post expressions</a></h4>
Post expressions are not
       accepted by the translator.
       
<h4><a name="id57">Disambiguation expressions</a></h4>
Disambiguation
       expressions are ignored (except set or map expressions which 
       involve empty sets or empty maps).
       
<h4><a name="id58">Bracketed expressions</a></h4>
Bracketed expressions
       are translated to SAL bracketed expressions.
       
<h4><a name="id59">Infix expressions</a></h4>
Statement infix expressions
       are not accepted by the translator. On the other hand, 
       the translation of the axiom infix expressions is
       straightforward. Table <a href="#Table5">13.2.5</a> shows how infix operators
       are translated.
<div align="center"><p>
<table><tbody><tr><td colspan="1" align="CENTER">

RSL </td><td colspan="1" align="CENTER"> SAL</td></tr>
<tr><td colspan="1" align="CENTER">
<font size="-1">&#8658;</font>  </td><td colspan="1" align="CENTER"> <tt>=&gt;</tt> </td></tr>
<tr><td colspan="1" align="CENTER">
<font size="-1">/&#92;</font> </td><td colspan="1" align="CENTER"> <tt>AND</tt> </td></tr>
<tr><td colspan="1" align="CENTER">
<font size="-1">&#92;/</font> </td><td colspan="1" align="CENTER"> <tt>OR</tt> </td></tr>
<tr><td colspan="1" align="CENTER">
</td></tr></tbody></table>

<div align="center"><a name="Table5"> Axiom</a> infix expressions</div>
</p></div>
       Regarding value infix expressions, all expressions using
       infix operations over elements of any basic type are directly
       translated into their SAL counterparts. But infix expressions
       that use set or map operations are handled differently.
<p>       Equality/Inequality infix operations for set and map, remain as
       infix operations in the translated code (collections are
       implemented as functions).
<p>       The names of the operations showed in tables <a href="#Table1">13.2.1</a> 
       and <a href="#Table2">13.2.1</a>, are turned into prefix operations during the
       translation process (SAL does not support 
       infix operator definitions for them).
       
<h4><a name="id61">Prefix expressions</a></h4>
A prefix expression
       generally translates to the corresponding SAL expression.
       For example, the expression ~ translates to <tt>NOT</tt>. The universal prefix expression, &#9633;, is not
       accepted by the translator.
<p>       The rest of the value prefix expressions translate to a
       function calls, using the function names described in Table <a href="#Table6">13.2.5</a>.        
On the other hand, the prefix operators <b>int</b>, <b>real</b>, <b>card</b>, <b>len</b>, <b>inds</b>, <b>elems</b>, <b>hd</b> and <b>tl</b> are
not accepted by the translator.
<div align="center"><p>
<table><tbody><tr><td colspan="1" align="CENTER">

RSL </td><td colspan="1" align="CENTER"> SAL</td></tr>
<tr><td colspan="1" align="CENTER">
<font size="-1">abs</font>  </td><td colspan="1" align="CENTER"> <tt>abs</tt> </td></tr>
<tr><td colspan="1" align="CENTER">
<font size="-1">dom </font> </td><td colspan="1" align="CENTER"> <tt>dom</tt> </td></tr>
<tr><td colspan="1" align="CENTER">
<font size="-1">rng</font> </td><td colspan="1" align="CENTER"> <tt>rng</tt> </td></tr>
<tr><td colspan="1" align="CENTER">
</td></tr></tbody></table>

<div align="center"><a name="Table6"> Translation</a> of built-in prefix operators</div>
</p></div>
       
<h4><a name="id63">Comprehended expressions</a></h4>
Comprehended
       expressions are not accepted by the translator.
       
<h4><a name="id64">Initialise expression</a></h4>
Initialization expressions
       are not accepted by the translator.
       
<h4><a name="id65">Assignment expressions</a></h4>
In the V1 of the
       translator, assignment expressions are only allowed when they
       describe transition systems (see <a href="ug_64.html#TS">13.3.2</a>). In this case, they
       are translated as SAL assignments.
       
<h4><a name="id66">Channel expressions expressions</a></h4>
Channel
       expressions are not accepted by the translator.
       
<h4><a name="id67">Local expressions</a></h4>
Local expressions are not
       accepted by the translator.
       
<h4><a name="id68">Let expressions</a></h4>
SAL supports let expressions
       for simple bindings, so the translation mechanism for simple
       expressions is straightforward. For example,
<p><font size="-1"><b>let</b> x = 0 <b>in</b> x + 1 <b>end</b></font>
<p>is translated to
<p><tt>LET x : IT&#95;AN!Int = 0 IN x + 1;</tt>
<p>Also it is possible translate more complex expressions, as you can see
in the next example,
<table cellspacing="1" cellpadding="0"><tr>
<td nowrap colspan="1" align="left">
                            &nbsp;&nbsp;&nbsp;</td><td nowrap colspan="1" align="left">&nbsp;&nbsp;&nbsp;</td><td nowrap colspan="1" align="left">&nbsp;&nbsp;&nbsp;</td><td nowrap colspan="1" align="left">&nbsp;&nbsp;&nbsp;</td><td nowrap colspan="1" align="left">&nbsp;&nbsp;&nbsp;</td><td nowrap colspan="1" align="left">&nbsp;&nbsp;&nbsp;</td><td nowrap colspan="1" align="left">&nbsp;&nbsp;&nbsp;</td><td nowrap colspan="1" align="left">&nbsp;&nbsp;&nbsp;</td><td nowrap colspan="1" align="left">&nbsp;&nbsp;&nbsp;</td><td nowrap colspan="1" align="left">&nbsp;&nbsp;&nbsp;</td><td nowrap colspan="1" align="left">&nbsp;&nbsp;&nbsp;</td><td nowrap colspan="1" align="left">&nbsp;&nbsp;&nbsp;</td><td nowrap colspan="99" align="left">&nbsp;</td></tr>
<tr>
<td nowrap colspan="99" align="left">&nbsp;<b>type</b></td></tr>
<tr>
<td nowrap colspan="1" align="left"></td><td nowrap colspan="99" align="left">&nbsp;Prod = <b>Int</b> &#215; <b>Int</b></td></tr>
<tr>
<td nowrap colspan="99" align="left">&nbsp;<b>value</b></td></tr>
<tr>
<td nowrap colspan="1" align="left"></td><td nowrap colspan="99" align="left">&nbsp;cons : <b>Int</b> &#215; <b>Int</b> &#8594; Prod</td></tr>
<tr>
<td nowrap colspan="1" align="left"></td><td nowrap colspan="99" align="left">&nbsp;cons(a, b) &#8801; <b>let</b> res = (a,b) <b>in</b> res <b>end</b>
</td></tr></table>

                        <p><p>is translated to
<pre>
  Prod: TYPE = [IT_AN!Int_, IT_AN!Int_];

  cons(a :IT_AN!Int_, b :IT_AN!Int_) : SAL_TYPES!Prod =
    LET res :[IT_AN!Int_, IT_AN!Int_] = (a, b) IN res;
</pre>
<p>The type of the bounded name in the let definition must be explicitly
stated in SAL’s model. On the other hand, the translation of binding involving products is more complex than
previous cases. SAL imposes that there is only single binding in
let expressions, preventing let expressions of the form "let (a,b) = P in" (where P is of product type). 
However, in SAL, product fields can be accessed by an index
associated according the field position inside the
product. The tool uses this feature to translate these expressions to
SAL. For example,
<table cellspacing="1" cellpadding="0"><tr>
<td nowrap colspan="1" align="left">
                            &nbsp;&nbsp;&nbsp;</td><td nowrap colspan="1" align="left">&nbsp;&nbsp;&nbsp;</td><td nowrap colspan="1" align="left">&nbsp;&nbsp;&nbsp;</td><td nowrap colspan="1" align="left">&nbsp;&nbsp;&nbsp;</td><td nowrap colspan="1" align="left">&nbsp;&nbsp;&nbsp;</td><td nowrap colspan="1" align="left">&nbsp;&nbsp;&nbsp;</td><td nowrap colspan="1" align="left">&nbsp;&nbsp;&nbsp;</td><td nowrap colspan="1" align="left">&nbsp;&nbsp;&nbsp;</td><td nowrap colspan="1" align="left">&nbsp;&nbsp;&nbsp;</td><td nowrap colspan="1" align="left">&nbsp;&nbsp;&nbsp;</td><td nowrap colspan="1" align="left">&nbsp;&nbsp;&nbsp;</td><td nowrap colspan="1" align="left">&nbsp;&nbsp;&nbsp;</td><td nowrap colspan="99" align="left">&nbsp;</td></tr>
<tr>
<td nowrap colspan="99" align="left">&nbsp;<b>value</b></td></tr>
<tr>
<td nowrap colspan="1" align="left"></td><td nowrap colspan="99" align="left">&nbsp;test : Prod &#8594; <b>Bool</b></td></tr>
<tr>
<td nowrap colspan="1" align="left"></td><td nowrap colspan="99" align="left">&nbsp;test(p) &#8801; <b>let</b> (a,b) = p <b>in</b> a &gt; 1 <b>end</b>
</td></tr></table>

                        <p><p>is translated to
<pre>
  test(p :SAL_TYPES!Prod): BT_AN!Bool_ =
    LET LetId3_ : SAL_TYPES!Prod = p IN LetId3_.1 &gt; 1;
</pre>
       
<h4><a name="id69">If expressions</a></h4>
The if expression translation is straightforward because SAL provides
IF-THEN-ELSE and ELSIF constructions. For example, the following
expression (<a href="ug_78.html#RLG92">[1]</a>, pg. 21)
<p><font size="-1"><b>if</b> x <i>&gt;</i> y <b>then</b> x - y <b>else</b> y - x <b>end</b></font>
<p>is translated to
<p><tt>IF x <i>&gt;</i> y THEN x - y ELSE y - x ENDIF</tt>
       
<h4><a name="id70">Case expressions</a></h4>
A case expression is translated as a nested sequence of "if"
expressions. For example, the expression
<table cellspacing="1" cellpadding="0"><tr>
<td nowrap colspan="1" align="left">
                            &nbsp;&nbsp;&nbsp;</td><td nowrap colspan="1" align="left">&nbsp;&nbsp;&nbsp;</td><td nowrap colspan="1" align="left">&nbsp;&nbsp;&nbsp;</td><td nowrap colspan="1" align="left">&nbsp;&nbsp;&nbsp;</td><td nowrap colspan="1" align="left">&nbsp;&nbsp;&nbsp;</td><td nowrap colspan="1" align="left">&nbsp;&nbsp;&nbsp;</td><td nowrap colspan="1" align="left">&nbsp;&nbsp;&nbsp;</td><td nowrap colspan="1" align="left">&nbsp;&nbsp;&nbsp;</td><td nowrap colspan="1" align="left">&nbsp;&nbsp;&nbsp;</td><td nowrap colspan="1" align="left">&nbsp;&nbsp;&nbsp;</td><td nowrap colspan="1" align="left">&nbsp;&nbsp;&nbsp;</td><td nowrap colspan="1" align="left">&nbsp;&nbsp;&nbsp;</td><td nowrap colspan="99" align="left">&nbsp;</td></tr>
<tr>
<td nowrap colspan="99" align="left">&nbsp;<b>case</b> x <b>of</b></td></tr>
<tr>
<td nowrap colspan="1" align="left"></td><td nowrap colspan="99" align="left">&nbsp;1 &#8594; 10,</td></tr>
<tr>
<td nowrap colspan="1" align="left"></td><td nowrap colspan="99" align="left">&nbsp;2 &#8594; 20,</td></tr>
<tr>
<td nowrap colspan="1" align="left"></td><td nowrap colspan="99" align="left">&nbsp;_ &#8594; 0</td></tr>
<tr>
<td nowrap colspan="99" align="left">&nbsp;<b>end</b>
</td></tr></table>

                        <p><p>is translated to
<pre>
IF (x = 1) THEN 10
  ELSIF (x = 2) THEN 20
  ELSE 0
ENDIF
</pre>
       
<h4><a name="id71">Iterative expressions</a></h4>
Iterative expressions
       <em>while</em>, <em>until</em> and <em>for</em> are not 
       accepted by the translator.
<hr /><address>Chris George, April 17, 2008</address><br />
<table width="100%" cellpadding="0"><tr>
    <td colspan="4" align="center" bgcolor="#99ccff" width="100%"><font size="+1"><b>13.2 Translatable RSL constructs</b></font></td></tr><tr><td width="30%"><table width="100%"><tr><td width="12%"><a href="ug_62.html"><img border="0" alt="13.1 Introduction" src="/home/Unuiist/www/icons/previous.gif"></img></a></td><td align="left" valign="middle">13.1 Introduction</td></tr></table></td><td width="30%"><table width="100%"><tr><td width="12%"><a href="ug_61.html"><img border="0" alt="13 SAL Translator" src="/home/Unuiist/www/icons/up.gif"></img></a>
   </td><td align="left" valign="middle">13 SAL Translator</td></tr></table></td><td width="30%"><table width="100%"><tr><td width="12%"><a href="ug_64.html"><img border="0" alt="13.3 Writing transition systems and LTL assertions" src="/home/Unuiist/www/icons/next.gif"></img></a>
   </td><td align="left" valign="middle">13.3 Writing transition systems and LTL assertions</td></tr></table></td></tr></table></body></html>
